*Number Theory Project 01*

* Common Core
** Basic Definitions/Methods
*** Confidentiality: 
    -keeping information private from unauthorized parties
*** Authentication: 
    -checking to make sure a piece of data came from the stated sender
*** Symmetric-key: 
    -when the same key is used for both encryption and decryption
*** Public-key: 
    -when  a different key is used for encryption and decryption
*** True Randomness: 
    -when effects occur that could never be traced to any cause (when an outcome can’t be predicted
*** Plaintext: 
    -data before encryption and after decryption
*** HSM: 
    -hardware security module, manages digital keys and provides cryptoprocessing
*** Integrity: 
    -making sure information is not modified by unauthorized parties
*** Steganography: 
    -the art and practice of communicating using hidden messages
*** Block Ciphers: 
    -a fixed-length group of bits (“block”) is modified with an unvarying transformation specified 
     by a symmetric key, used often with encryption of bulk data
*** Private key: 
    -keys only known to the owner
*** Kerckhoffs’s Principle: 
    -“A cryptosystem should be secure even if everything about the system, except the key, is public knowledge.”
*** Digital signatures: 
    -a mathematical technique used to validate the authenticity and integrity of a message, software or digital document
*** SHA: 
    -secure hash algorithms, a family of cryptographic hash functions published by the 
     National Institute of Standards and Technology as a U.S. Federal Information Processing Standards
*** Non-repudiation: 
    -the assurance that someone cannot deny something, or the ability to ensure that a party 
     to a contract or a communication cannot deny the authenticity of their signature on a document 
     or the sending of a message that they originated
*** Cryptography: 
    -the art of writing or solving codes
*** Stream Ciphers: 
    -a symmetric key cipher where plaintext digits are combined with a pseudorandom cipher digit stream
*** The Enigma Machine: 
    -a series of electro-mechanical rotor cipher machines developed and used in the early- to mid-20th century to protect information
*** Ciphertext: 
    -information that has been encrypted
*** GPG: 
    -GNU Privacy Guard, free security software
*** Key Exchange: 
    -any method in cryptography by which keys are exchanged between two parties, allowing use of a cryptographic algorithm

** The Enigma Machine
   So, there were two groups that cracked the Enigma machine. The Poles were able to decode Enigma ciphertexts as early as 1932,
   and the British, with Alan Turing, were able to crack the Enigma in 1939 with "the bombe". The Poles captured a codebook from 
   the French and worked their way back. Alan Turing and his team made a computer to do their work for them.
** Password Strength Security
resultscode
resultssilent
resultsraw
resultsoutput

#+BEGIN_SRC elisp :results output
(defun psswrd_chckr()
   "Simple way to check the strength of a password

   We are going to control how many possible combinations there are
   with some state variables. Basically, if a character in the password
   is contained in one of these sets, we flip a bit to tell us so. I would
   do one for the symbols but that seems like too much work. Let's assume
   that there are 32 on a standard keyboard (Don't worry, I counted on mine)."
   
   ; Password to check, at the top for your convenience
   ; Keep it around 10 characters, please (it's not set up for long passwords)
   (setq psswrd "")   

   ; Sets to compare to
   (setq lowercase '(97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122))
   (setq uppercase '(65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90))
   (setq numbers '(48 49 50 51 52 53 54 55 56 57))
   (setq symbols '(32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 64 91 92 93 94 95 96 123 124 125 126))

   ; Status container
   (setq LOWERCASE 0)
   (setq UPPERCASE 0)
   (setq NUMBERS 0)
   (setq SYMBOLS 0)
   
   ; Variables needed for the math operations
   (setq attacks_per_second (* 1.7 0.000001))
   (setq num_combinations 0)
   
   ; The value we are really concerned with!
   (setq strength 0)
   
   ; Find the length of the password string
   (setq psswrd_length (length (symbol-value 'psswrd)))
   
   ; Iterate through the string
   (setq count 0)
   (while (< count psswrd_length)
      (if (member (elt psswrd count) lowercase) ; if the current element is lowercase, set this variable "High"
         (setq LOWERCASE 1)
      )
      (if (member (elt psswrd count) uppercase)
         (setq UPPERCASE 1)
      )
      (if (member (elt psswrd count) numbers) ; we can use the member operator because the symbols and numbers are
         (setq NUMBERS 1)                     ;    represented by their ascii values
      )
      (if (member (elt psswrd count) symbols)
         (setq SYMBOLS 1)
      )
      (setq count (1+ count)))

   ; Set number of combinations
   (if (equal LOWERCASE 1)
      (setq num_combinations (+ num_combinations 26)))
   (if (equal UPPERCASE 1)
      (setq num_combinations (+ num_combinations 26)))
   (if (equal NUMBERS 1)
      (setq num_combinations (+ num_combinations 10)))
   (if (equal SYMBOLS 1)
      (setq num_combinations (+ num_combinations 33)))

   ; Calculate the strength
   (cond ((and (< 00 num_combinations) (< num_combinations 27)) (setq strength 1))
         ((and (< 27 num_combinations) (< num_combinations 53)) (setq strength 2))
         ((and (< 53 num_combinations) (< num_combinations 63)) (setq strength 3))
         ((and (< 63 num_combinations) (< num_combinations 96)) (setq strength 4))
   )
   ; Output the strength
   (print "On a scale of one to four, your password strength is:")
   (print strength)
)
(psswrd_chckr)
#+END_SRC
** Caesar Cipher

#+BEGIN_SRC elisp :results output
(defun caesar_cipher()
   "An elisp implementation of a Caesar cipher"
   
   ; The plain text and key up front and personal
   (setq plaintext "helloz")
   (setq key ?b)

   ; Find the length of the password
   (setq msg_length (length (symbol-value 'plaintext)))

   ; Make the password and key lowercase
   (setq lower_letters (downcase plaintext))
;   (setq lower_key (downcase key))

   ; Find the actual amount to shift the plaintext from the key
   (setq key_number (% key 96))

   ; Encrypt!
   ;    -Loop through the entire password
   ;    -add the key to each letter in the password  
   (setq count 0)
   (setq ciphertext '())
   (while (< count msg_length)
      (setq ciphertext (cons (% (+ key_number (elt plaintext count)) 122) ciphertext))
      (setq count (1+ count))
   )


   ; As the code stands now, if we get any wrap around, our values will be less than 97,
   ;   so we'll be losing our ascii values. This loop is meant to fix that
   (setq count2 0)
   (setq cipher_with_loop '())
   (while (< count2 (length (symbol-value 'ciphertext)))
      (if (< (elt ciphertext count2) 97)
         (setq cipher_with_loop (cons (+ 96 (elt ciphertext count2)) cipher_with_loop))
       (setq cipher_with_loop (cons (elt ciphertext count2) cipher_with_loop))
      )
      (setq count2 (1+ count2))
   )

   ; Print out the encrypted ciphertext
   (setq count3 0)
   (setq encrpyted_text '())
   (while (< count3 (length (symbol-value 'cipher_with_loop)))
      (print (char-to-string (elt cipher_with_loop count3)))
      (setq count3 (1+ count3))
   )
)

(caesar_cipher)
#+END_SRC

#+RESULTS:
#+begin_example

"j"

"g"

"n"

"n"

"q"

"b"
#+end_example

